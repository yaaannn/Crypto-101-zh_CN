异或
------------

说明
~~~~~~~~~~~

异或，通常称为“XOR”，是一个布尔 [#boolean]_ 二进制 [#binary]_ 运算符，当第一个输入和第二个输入不相同时，该运算结果为true。

另一种思考XOR的方式是称为“可编程逆变器”的东西：一个输入位决定是倒置另一个输入位，还是直接输出不做改变。“倒置”位通俗地称为“翻转”位，我们将在全书中经常使用这个术语。

.. figure:: Illustrations/XOR/ProgrammableInverter.svg
   :alt: a programmable inverter
   :align: center

在数学和密码学论文中，异或一般用内嵌十字的圆圈表示： :math:`\xor`。
本书将使用同样的符号：

.. figure:: Illustrations/XOR/XOR.svg
   :align: center
   :alt: XOR

此处的输入和输出的命名就好像我们将XOR用作加密操作一样。
左边是明文比特 :math:`P_i`。
:math:`i` 只是一个索引，因为我们通常会处理多个这样的比特位。
上面我们有一个密钥比特 :math:`k_i`，它决定是否反转 :math:`P_i`。
在右边，我们有密文比特 :math:`C_i`，这是XOR操作的结果。

.. [#boolean]
   仅使用“true”和“false”作为输入和输出值。

.. [#binary]
   取两个参数

XOR的几个性质
~~~~~~~~~~~~~~~~~~~~~~~

由于在本书中我们将广泛地涉及和使用XOR，所以我们将仔细研究它的一些特性。
如果你已经熟悉XOR，可以跳过本节。

我们知道两个输入中一个为（但不都为）1时，XOR的输出为1。

.. math::

   \begin{array}{c@{\hspace{2em}}c}
   0 \xor 0 = 0 & 1 \xor 0 = 1 \\
   0 \xor 1 = 1 & 1 \xor 1 = 0
   \end{array}

我们可以从中得出一些有用的运算技巧：

#. XOR运算可以任意调换顺序： :math:`a \xor (b \xor c) = (a \xor b) \xor c`
#. 可以反转操作数： :math:`a \xor b = b \xor a`
#. 任何比特异或本身的结果是 0： :math:`a \xor a = 0`
#. 任何比特异或0等于本身： :math:`a \xor 0 = a`

以上性质可以推出 :math:`a \xor b \xor a = b`：

.. math::

   \begin{aligned}
   a \xor b \xor a & = a \xor a \xor b & \; & \text{(性质2)} \\
                   & = 0 \xor b        & \; & \text{(性质3)} \\
                   & = b               & \; & \text{(性质4)}
   \end{aligned}

在使用XOR进行加密时，我们经常使用这条性质。你可以将第一个XOR :math:`a` 视为加密，而将第二个XOR视为解密。

按位异或
~~~~~~~~~~~

我们刚刚定义的异或运算只对单个比特位或布尔值进行操作。
由于我们通常处理值通常由许多比特位组成，大多数编程语言都提供了一个“按位异或”运算符：对一个值进行逐位异或运算的运算符。

例如，Python 提供了 ``^`` (脱字符号) 运算符，可以对整数进行按位异或。它首先用二进制 [#binary-integer]_
表示这两个整数，然后对它们各自的比特位进行异或运算。因此，它的名字叫 *按位* 异或。

.. math::

   \begin{aligned}
   73 \xor 87 & = 0b1001001 \xor 0b1010111 \\
              & = \begin{array}{*{7}{C{\widthof{$\xor$}}}c}
                      1    & 0    & 0    & 1    & 0    & 0    & 1    & \quad \text{(左)}\\
                      \xor & \xor & \xor & \xor & \xor & \xor & \xor & \\
                      1    & 0    & 1    & 0    & 1    & 1    & 1    & \quad \text{(右)}\\
                  \end{array} \\
              & = \begin{array}{*{7}{C{\widthof{$\xor$}}}}
                      0    & 0    & 1    & 1    & 1    & 1    & 0
                  \end{array} \\
              & = 0b0011110 \\
              & = 30 \\
   \end{aligned}

.. [#binary-integer]
   通常情况下，数字内部就是以二进制形式存储，所以这实际上不需要任何工作。当你看到一个以"0b"为前缀的数字时，剩下的数字都是二进制表示。

一次性密码本
~~~~~~~~~~~~~

XOR可能看起来是一个非常简单，甚至是微不足道的运算符。
即使如此，有一种加密方案，叫做一次性密码本，它只由这一个运算符组成。
它被称为一次性密码本，因为它涉及到一个随机位的序列（本子），而方案的安全性取决于密码本只使用一次。
这个序列之所以被称为密码本，是因为它最初是记录在一本实体纸质本子上。

这个方案的独特之处不仅在于它的简单性，还在于它具有最强的安全保证。
如果所有比特是真随机的（因此攻击者无法预测），而且密码本只用一次，那么攻击者在看到密文时，就不会获取到任何有关于明文的信息。
[#msg-exists]_

.. [#msg-exists]
   攻击者确实知道了消息的存在，以及在这个简单的方案中，消息的长度。
   虽然这通常不是太重要，但在某些情况下，这可能很重要，而且有一些安全的密码系统可以同时隐藏信息的存在和长度。


假设我们可以将明文翻译成一个比特序列。
发送者和接受者共享了记录着随机比特序列的密码本（一个或多个），我们可以通过对两个比特序列进行位操作来计算密文。

.. figure:: Illustrations/XOR/OTP.svg
   :align: center
   :alt: OTP

如果攻击者看到了密文，我们可以证明他们在没有密钥的情况下，无法得到关于明文的任何信息。
这个特性被称为 *完美安全* 。
把XOR看成是一个可编程逆变器，然后把某一个比特看作被窃听者窃听到了，就可以直观地理解这个证明。


.. figure:: Illustrations/XOR/OTPEve.svg
   :align: center
   :alt: OTP eve

假设窃听者Eve看到某个密文比特 :math:`c_i` 是1，她不知道匹配的明文比特 :math:`p_i` 是0还是1，因为她不知道密钥比特 :math:`k_i` 是0还是1。
由于所有的密钥位都是真随机的，所以这两个值的可能性完全相同。

攻击“一次性密码本”
~~~~~~~~~~~~~~~~~~~~~~~~~~

一次性密码本的安全保证只有在正确使用的情况下才有效。 首先，一次性密码本包含的数据必须是真随机的。其次，一次性密码本只能使用一次（名称的由来）。
不幸的是，大多数声称是“一次性密码本”的商业产品都是蛇油 [#snake-oil]_，没有满足上面两种要求中的至少一种。


.. [#snake-oil]
   “蛇油”是对各种可疑产品的称呼，它们宣称有非凡的好处和功能，但其实什么用也没有。

没有用真正的随机数据
^^^^^^^^^^^^^^^^^^^^^^^^^^^

第一个问题是，他们使用各种可预测的方式来生成一次性密码本，而不是使用真正的随机数据。
这未必就不安全：实际上，最明显的例子是同步流密码，这将在本书的后面看到。 但是，它会使一次性密码本的“牢不可破”的安全属性无效。
一个更可靠的密码系统将更好地服务于终端用户，而不是谎报其安全性的密码系统。

重复使用“一次性”密码本
^^^^^^^^^^^^^^^^^^^^^^^^^^

另一个问题是密钥重用的问题，这个问题要严重得多。假设一个攻击者得到了两个使用相同“一次性”密码本的密文。攻击者就可以对这两个密文进行异或，也就是两个明文的异或。

.. math::

   \begin{aligned}
   c_1 \xor c_2
   &= (p_1 \xor k) \xor (p_2 \xor k) && (\text{definition})\\
   &= p_1 \xor k \xor p_2 \xor k && (\text{reorder terms})\\
   &= p_1 \xor p_2 \xor k \xor k && (a \xor b = b \xor a) \\
   &= p_1 \xor p_2 \xor 0 && (x \xor x = 0) \\
   &= p_1 \xor p_2 && (x \xor 0 = x)
   \end{aligned}

乍一看，这似乎没什么问题。因为要提取出 :math:`p_1` 或 :math:`p_2`，你需要抵消异或运算，这意味着你需要知道另一个密文的明文。
问题在于，即便两个明文异或的结果也包含有关明文本身的大量信息。
我们将用一些破解的“一次性”密码本过程的图片来直观地说明这一点，首先是 :numref:`fig-multitimepad`。

.. figmatrix::
   :label: fig-multitimepad
   :width: 0.48

   .. subfigure:: ./Illustrations/KeyReuse/Broken.png
      :alt:
      :align: center

      第一条明文

   .. subfigure:: ./Illustrations/KeyReuse/Crypto.png
      :alt:
      :align: center

      第二条明文

   .. subfigure:: ./Illustrations/KeyReuse/BrokenEncrypted.png
      :alt:
      :align: center

      第一条密文

   .. subfigure:: ./Illustrations/KeyReuse/CryptoEncrypted.png
      :alt:
      :align: center

      第二条密文

   .. subfigure:: ./Illustrations/KeyReuse/Key.png
      :alt:
      :align: center

      被重用的密钥

   .. subfigure:: ./Illustrations/KeyReuse/CiphertextsXOR.png
      :alt:
      :align: center

      两条密文的异或

   两条明文，重用的密钥，它们各自的密文和两条密文的异或。当我们对密文进行异或运算时，明文的相关信息显然会泄漏出去。

Crib-dragging
^^^^^^^^^^^^^

破解非重用一次性密码本系统的一个经典方法是“crib-dragging”，这是一个使用期望的高概率出现的小序列的过程。这些序列被称为
“cribs”。crib-dragging这个名字的由来是：这些小的“cribs”会被拖动到密文的各个地方，上下左右来寻找到匹配。这些匹配构成了进一步解密的起点，或者说“crib”，如果你愿意的话，就可以进行进一步的解密。

这个想法相当简单。假设我们有几个加密的信息 :math:`C_i` 用相同的“一次性”密码本 :math:`K` [#capital-letters]_ 加密。
如果我们能正确地猜出其中一条信息的明文，比如说 :math:`C_j`，我们就可以知道 :math:`K`。

.. [#capital-letters]
   我们使用大写字母指代整条信息，以对应小写指代信息中的部分比特。


.. math::

   \begin{aligned}
   C_j \xor P_j
   &= (P_j \xor K) \xor P_j \\
   &= K \xor P_j \xor P_j \\
   &= K \xor 0 \\
   &= K
   \end{aligned}

由于 :math:`K` 是一个共享的秘密，我们现在可以像接收者一样用它来解密其他所有的消息。

.. math::

   P_i = C_i \xor K \qquad \text{for all }i

由于我们通常无法猜测出整条消息，这实际上是行不通的。然而，我们也许能够猜到信息的部分内容。

如果我们正确地猜测了 *任意* 一条信息中的几个明文比特 :math:`p_i`，那么就会泄露 *所有* 信息在该位置的密文比特位，因为 :math:`k = c_i \xor p_i`。
因此，该位置的所有明文比特位都会被泄露出来：使用 :math:`k`的值，我们可以计算所有其他信息的明文比特位 :math:`p_i = c_i \xor k`。

猜测部分明文比猜测整个明文要容易得多。假设我们知道明文是用英语写的，我们知道有些单词或短语会很常见，例如（符号 :math:`\verb*| |` 表示一个空格）：

-  :math:`\verb*| the |` 以及变种，例如 :math:`\verb*| The |`
-  :math:`\verb*| of |` 以及变种
-  :math:`\verb*| to |` 以及变种
-  :math:`\verb*| and |` (没有变种，仅出现在语句的中间)
-  :math:`\verb*| a |` 以及变种

如果我们对明文有更多的了解，我们可以做出更好的猜测。例如，如果是服务HTML的HTTP，我们就会猜测 ``Content-Type``、 ``<a>`` 等等。

这只是告诉我们哪些明文序列是可能的，让我们有可能的猜测。
我们如何判断这些猜测中是否有正确的呢？如果我们的猜测是正确的，使用前面描述的技术，我们也就知道了所有其他密文该位置的明文。
我们可以简单地查看这些明文，并判断它们看起来是否正确。

在实践中，这个过程需要自动化，因为可能的猜测太多。幸运的是，这很容易做到。
例如，一个非常简单但有效的方法是计算不同符号在猜测的明文中出现的频率：如果消息中包含英文文本，我们希望看到很多字母e、t、a、o、i、n，
如果我们看到的是胡乱的二进制数据，我们就知道猜测可能是不正确的，或者说该消息实际上是二进制数据。

这些小的、极高可能频率的序列被称为“cribs”，因为它们是一个更大的解密过程的开始。假设你的crib ``the`` 成功地在另一条信息中找到了 ``t thr``的五个字母序列。
然后你可以用字典找到以 ``thr`` 开头的常用词，比如 ``through``。
如果这个猜测是正确的，就会在所有的密文中多破解出四个字节，可以用来揭示更多的信息。
同样，你可以使用字典来查找以 ``t`` 结尾的词。

对于一些我们比较了解的明文，这就变得更加有效。如果一些HTTP数据中含有明文 ``ent-Len``，那么我们就可以将其扩展为 ``Content-Length:``，揭示出更多的字节。

虽然这种技术只要用相同的密钥对两个消息进行加密就可以了，但很明显，如果更多的密文使用了相同的密钥加密，这个方法就会变得更加容易，因为所有的步骤都变得更加有效：

-  更多crib位置.
-  每一次成功的匹配和猜测都会泄露出更多的明文字节，导致其他地方有更多的猜测选择。
-  一个位置的密文越多，使得猜测验证更容易，有时也更准确。

这些只是破解重用一次性密码本的一些简单想法。虽然它们已经相当有效，但人们通过应用基于自然语言分析的高级统计模型，发明了更有效的方法。这只能进一步证明重用一次性密码本破绽有多大。 :cite:`mason:nltwotimepads` 。

遗留问题
~~~~~~~~~~~~~~~~~~

真正的一次性密码本，实现得当，有极强的安全保障。这样看来，密码学似乎已经结束了：加密问题解决了，我们都可以回家了。显然，事实并非如此。

一次性密码本很少被使用，因为它们太不实用了：密钥至少要和你想传输的所有信息 *加在一起* 一样大。
另外，你必须提前和所有你想交流的人安全地交换这些密钥。
我们想和互联网上的所有人安全地交流，那是一个非常庞大的数字。
此外，由于密钥必须由真正的随机数据组成，才能保证安全，如果没有专门的硬件，密钥的生成是相当困难和耗时的。

一次性密码本有取有舍。它是一种具有坚实的信息论安全保证的算法，这是其他任何系统都无法获得的。
另一方面，它也有极其不切实际的密钥交换要求。然而，正如我们在本书中看到的，安全的对称加密算法并不是现代密码系统的痛点。
密码学家们已经设计了很多安全的对称加密算法，而实用的密钥管理仍然是现代密码学面临的最艰难的挑战之一。
一次性密码本也许解决了一个问题，但这不是要解决的问题。


虽然它们可能有其用途，但显然不是万灵药。我们需要一个可控密钥大小，同时保持保密性的方法。我们需要一些可以通过互联网与从未谋面的人协商密钥的方法。