# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Laurens Van Houtven (lvh)
# This file is distributed under the same license as the Crypto 101 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 振霞 苑 <yuanzhenxia-2008@163.com>, 2021
# fang xing <fangxing204@gmail.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Crypto 101 f82123a\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-16 22:25-0700\n"
"PO-Revision-Date: 2020-06-07 15:30+0000\n"
"Last-Translator: fang xing <fangxing204@gmail.com>, 2021\n"
"Language-Team: Chinese (https://app.transifex.com/crypto101/teams/110558/zh/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../src/block-ciphers.rst:2
msgid "Block ciphers"
msgstr "分组密码"

#: ../../src/block-ciphers.rst:4
msgid ""
"Few false ideas have more firmly gripped the minds of so many intelligent "
"men than the one that, if they just tried, they could invent a cipher that "
"no one could break."
msgstr "很多聪明人都有一个坚定的错误想法，那就是只要他们尝试，就能发明出一个无人能破解的加密方法。"

#: ../../src/block-ciphers.rst:8
msgid "*David Kahn*"
msgstr "*大卫·卡恩*"

#: ../../src/block-ciphers.rst:13
msgid "Description"
msgstr "说明"

#: ../../src/block-ciphers.rst:15
msgid ""
"A :term:`block cipher` is an algorithm that allows us to encrypt blocks of a"
" fixed length. It provides an encryption function :math:`E` that turns "
"plaintext blocks :math:`P` into ciphertext blocks :math:`C`, using a secret "
"key :math:`k`:"
msgstr ""
":term:`分组密码`是一种允许我们对多个固定长度的块进行加密的算法。它提供了一个加密函数 :math:`E`，通过一个密钥 "
":math:`k`，将明文块 :math:`P`转换成密文块 :math:`C`。"

#: ../../src/block-ciphers.rst:20
msgid "C = E(k, P)"
msgstr "C = E(k, P)"

#: ../../src/block-ciphers.rst:24
msgid ""
"The plaintext and ciphertext blocks are sequences of bits. They are always "
"the same size as one another, and that size is fixed by the block cipher: "
"it's called the block cipher's *block size*. The set of all possible keys is"
" called the :term:`keyspace`."
msgstr ""
"明文和密文块都是比特序列。它们的大小都是相同的，这个大小是由分组密码固定的：它被称为分组密码的*块大小*。所有可能的密钥的集合称为 "
":term:`密钥空间`。"

#: ../../src/block-ciphers.rst:29
msgid ""
"Once we've encrypted plaintext blocks into ciphertext blocks, they later "
"have to be decrypted again to recover the original plaintext block. This is "
"done using a decryption function :math:`D`, which takes the ciphertext block"
" :math:`C` and the key :math:`k` (the same one used to encrypt the block) as"
" inputs, and produces the original plaintext block :math:`P`."
msgstr ""
"一旦我们把所有明文块加密成密文块，之后就必须再次解密以恢复原来的明文块。这是用一个解密函数 :math:`D`来完成的，它将密文块 "
":math:`C`和密钥 :math:`k`（与加密块所用的密钥相同）作为输入，并产生原始的明文块 :math:`P`。"

#: ../../src/block-ciphers.rst:36
msgid "P = D(k, C)"
msgstr "P = D(k, C)"

#: ../../src/block-ciphers.rst:40
msgid "Or, in blocks:"
msgstr "或者，分组："

#: ../../src/block-ciphers.rst:45
msgid ""
"Block ciphers are an example of a :term:`symmetric-key encryption` scheme, "
"also known as a :term:`secret-key encryption` scheme. This means that the "
"same secret key is used for both encryption and decryption. We will contrast"
" this with :term:`public-key encryption` algorithms, which have a distinct "
"key for encryption and decryption, later in the book."
msgstr ""
"分组密码是:term:`对称密钥加密`方案的一个例子，也称为 :term:`私密密钥加密`方案。这意味着加密和解密都使用同一个秘钥。我们将在本书后面与 "
":term:`公钥加密`算法进行对比，后者的加密和解密使用不同的密钥。"

#: ../../src/block-ciphers.rst:51
msgid ""
"A block cipher is a *keyed permutation*. It's a *permutation*, because the "
"block cipher maps every possible block to some other block. It's also a "
"*keyed* permutation, because the key determines exactly which blocks map to "
"which. It's important that it's a permutation, because the recipient needs "
"to be able to map blocks back to the original blocks as well, which you can "
"only do if it's one-to-one."
msgstr ""
"分组加密是一种*加密置换*。它是一种*置换*，因为分组加密将每一个可能的块映射到其他块上。它也是一个*加密的置换*，因为密钥确切地决定了块之间的映射。它是一个置换这很重要，因为接受者也需要能够将每块映射回原来的块，只有当它是一对一的时候，你才能做到这一点。"

#: ../../src/block-ciphers.rst:58
msgid ""
"We'll illustrate this by looking at a block cipher with an impractical, tiny"
" 4-bit block size, so :math:`2^4 = 16` possible blocks. Since each of those "
"blocks maps to a hexadecimal digit, we'll represent the blocks by that "
"digit. :numref:`fig-BlockCipherBlocks` illustrates the blocks that the "
"cipher operates on."
msgstr ""
"我们将通过一个不实用的、微小的4位块大小的分组密码来说明这一点，:math:`2^4 = 16`可能的块。:numref:`fig-"
"BlockCipherBlocks`说明了分组密码是如何操作这些块的。"

#: ../../src/block-ciphers.rst:70
msgid ""
"All of the 16 nodes operated on by the block cipher. Each node is designated"
" by a hexadecimal digit."
msgstr "分组加密所操作的16个节点中的所有节点，每个节点由一个十六进制数字表示。"

#: ../../src/block-ciphers.rst:72
msgid ""
"Once we select a secret key, the block cipher will use that to determine "
"what the encryption of any given block is. We will illustrate that "
"relationship with an arrow: the block at the start of the arrow, encrypted "
"using :math:`E` under key :math:`k`, is mapped to the block at the end of "
"the arrow."
msgstr ""
"一旦我们选择了一个秘密密钥，分组加密就会用它来确定任何给定块的加密内容。我们将用一个箭头来说明这种关系：箭头开头的区块，在密钥:math:`k`下使用:math:`E`加密，被映射到箭头末端的区块。"

#: ../../src/block-ciphers.rst:83
msgid ""
"An encryption permutation produced by the block cipher under a particular "
"key :math:`k`."
msgstr "分组加密在特定的密钥下产生的加密排列:math:`k`。"

#: ../../src/block-ciphers.rst:85
msgid ""
"In :numref:`fig-BlockCipherEncryption`, you'll notice that the permutation "
"isn't just one big cycle: there's a large cycle of 7 elements, and several "
"smaller cycles of 4, 3 and 2 elements each. It's also perfectly possible "
"that an element encrypts to itself. This is to be expected when selecting "
"random permutations, which is approximately what a block cipher is doing; it"
" doesn't demonstrate a bug in the block cipher."
msgstr ""
"在 :numref:`fig-"
"BlockCipherEncryption`中，你会注意到，置换并不只是一个大环：有一个7个元素的大环，还有几个小环，分别是4个、3个和2个元素。一个元素对自己加密也是完全有可能的。这是在选择随机排列时可能出现的，这可能就是分组加密的做法，它并不是来展示分组加密的一个错误。"

#: ../../src/block-ciphers.rst:93
msgid ""
"When you're decrypting instead of encrypting, the block cipher just computes"
" the inverse permutation. In :numref:`fig-BlockCipherDecryption`, you can "
"see that we get the same illustration, except that all the arrows are going "
"in the other direction."
msgstr ""
"当你在解密而不是加密的时候，分组加密只是计算逆向置换。在 :numref:`fig-"
"BlockCipherDecryption`中，你可以看到我们得到了同样的说明，只是所有的箭头都是朝另一个方向。"

#: ../../src/block-ciphers.rst:103
msgid ""
"The decryption permutation produced by the block cipher under the same key "
":math:`k`: the inverse of the encryption permutation, that is: all the "
"arrows have been reversed."
msgstr "分组加密在同一密钥下产生的解密置换 :math:`k`：是 加密置换反向，即：所有的箭头都被反转了。"

#: ../../src/block-ciphers.rst:108
msgid ""
"The only way to know which block maps to which other block, is to know the "
"key. A different key will lead to a completely different set of arrows, as "
"you can see in :numref:`fig-BlockCipherEncryptionDifferentKey`."
msgstr ""
"要知道哪个区块映射到哪个其他区块，唯一的方法就是知道密钥。不同的密钥将导致一组完全不同的箭头，你可以在:numref:`fig-"
"BlockCipherEncryptionDifferentKey`中看到。"

#: ../../src/block-ciphers.rst:117
msgid ""
"An encryption permutation produced by the block cipher under some other key."
msgstr "分组加密在其他密钥下产生的一种加密置换方式。"

#: ../../src/block-ciphers.rst:119
msgid ""
"In this illustration, you'll even notice that there are two permutations of "
"length 1: an element that maps to itself. This is again something to be "
"expected when selecting random permutations."
msgstr "在这个插图中，你甚至会注意到，有两个长度为1的排列组合：一个元素映射到自身。这又是在选择随机排列时可以预期的事情。"

#: ../../src/block-ciphers.rst:123
msgid ""
"Knowing a bunch of (input, output) pairs for a given key shouldn't give you "
"any information about any other (input, output) pairs under that key [#]_. "
"As long as we're talking about a hypothetical perfect block cipher, there's "
"no easier way to decrypt a block other than to “brute-force” the key: i.e. "
"just try every single one of them until you find the right one."
msgstr ""
"知道一个给定密钥的一堆（输入、输出）对，不应该从中得到任何关于该密钥[#]_下的其他（输入、输出）对的信息。只要我们谈论的是一个假设的完美的分组加密，除了“暴力破解”密钥之外，没有其他更简单的方法来解密一个组：即只有一个一个尝试，直到找到正确的那一个。"

#: ../../src/block-ciphers.rst:131
msgid ""
"The attentive reader may have noticed that this breaks in the extremes: if "
"you know all but one of the pairs, then you know the last one by exclusion."
msgstr "细心的读者可能已经注意到了，这在极端情况下是有特例的：如果你知道所有的映射对，但有一个不知道，那么你就会通过排除法知道最后一个。"

#: ../../src/block-ciphers.rst:135
msgid ""
"Our toy illustration block cipher only has 4 bit blocks, or :math:`2^4 = 16`"
" possibilities. Real, modern block ciphers have much larger block sizes, "
"such as 128 bits, or :math:`2^{128}` (slightly more than :math:`10^{38.5}`) "
"possible blocks. Mathematics tells us that there are :math:`n!` (pronounced "
"“:math:`n` factorial”) different permutations of an :math:`n` element set. "
"It's defined as the product of all of the numbers from 1 up to and including"
" :math:`n`:"
msgstr ""
"我们的玩具演示分组加密， 每组只有4位，也就是每组有 :math:`2^4 = 16`种可能。真正的、现代的分组加密有更大的区块大小，如128位，或 "
":math:`2^{128}`（比 :math:`10^{38.5}`略多）可能的区块。数学告诉我们，一个 :math:`n`元素集有 "
":math:`n!`（读作\":math:`n`阶乘\"）不同的排列组合。它被定义为从1到并包括 :math:`n`的所有数字的乘积。"

#: ../../src/block-ciphers.rst:143
msgid "n! = 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (n - 1) \\cdot n"
msgstr "n! = 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (n - 1) \\cdot n"

#: ../../src/block-ciphers.rst:147
msgid ""
"Factorials grow incredibly quickly. For example, :math:`5! = 120`, "
":math:`10! = 3628800`, and the rate continues to increase. The number of "
"permutations of the set of blocks of a cipher with a 128 bit block size is "
":math:`(2^{128})!`. Just :math:`2^{128}` is large already (it takes 39 "
"digits to write it down), so :math:`(2^{128})!` is a mind-bogglingly huge "
"number, impossible to comprehend. Common key sizes are only in the range of "
"128 to 256 bits, so there are only between :math:`2^{128}` and "
":math:`2^{256}` permutations a cipher can perform. That's just a tiny "
"fraction of all possible permutations of the blocks, but that's okay: that "
"tiny fraction is still nowhere near small enough for an attacker to just try"
" them all."
msgstr ""
"阶乘的增长速度快得惊人。比如:math:`5! = 120`，:math:`10! "
"=3628800`，而且速度还在继续增加。组大小为128位的密码的组集的排列个数为:math:`(2^{128})！`。只是:math:`2^{128}`已经很大了(需要39位数字才能写下来)，所以:math:`(2^{128})!`是一个令人匪夷所思的巨大数字，无法理解。常见的密钥大小只在128到256位之间，所以一个密码能进行的排列组合只有:math:`2^{128}`和:math:`2^{256}`之间。这只是所有可能的分组组合中的一小部分，但没关系：这一小部分还远远没有小到让攻击者可以尝试所有的组合。"

#: ../../src/block-ciphers.rst:159
msgid ""
"Of course, a block cipher should be as easy to compute as possible, as long "
"as it doesn't sacrifice any of the above properties."
msgstr "当然，只要不会牺牲上述任何一个特性前提下，分组加密应该尽可能地易于计算。"

#: ../../src/block-ciphers.rst:163
msgid "AES"
msgstr "AES"

#: ../../src/block-ciphers.rst:165
msgid "The most common block cipher in current use is AES."
msgstr "目前最常用的分组加密是AES。"

#: ../../src/block-ciphers.rst:167
msgid ""
"Contrary to its predecessor DES (which we'll look at in more detail in the "
"next chapter), AES was selected through a public, peer-reviewed competition "
"following an open call for proposals. This competition involved several "
"rounds where all of the contestants were presented, subject to extensive "
"cryptanalysis, and voted upon. The AES process was well-received among "
"cryptographers, and similar processes are generally considered to be the "
"preferred way to select cryptographic standards."
msgstr ""
"与它的前身DES（我们将在下一章中详细介绍）相反，AES是在公开征集提案后，通过公开的、经过同行评审的竞赛选出的。这个竞选包括几轮，所有的参赛者都会被介绍，接受广泛的密码分析，并进行投票。AES程序在密码学家中受到好评，类似的程序一般被认为是选择密码标准的首选方式。"

#: ../../src/block-ciphers.rst:175
msgid ""
"Prior to being chosen as the Advanced Encryption Standard, the algorithm was"
" known as Rijndael, a name derived from the two last names of the Belgian "
"cryptographers that designed it: Vincent Rijmen and Joan Daemen. The "
"Rijndael algorithm defined a family of block ciphers, with block sizes and "
"key sizes that could be any multiple of 32 bits between 128 bits and 256 "
"bits. :cite:`daemen:aes` When Rijndael became AES through the FIPS "
"standardization process, the parameters were restricted to a block size of "
"128 bits and keys sizes of 128, 192 and 256 bits. :cite:`fips:aes`"
msgstr ""
"在被选为高级加密标准之前，该算法被称为Rijndael，这个名字来源于设计该算法的比利时密码学家的两个姓氏。Vincent Rijmen和Joan "
"Daemen。Rijndael算法定义了一个分组密码家族，其组大小和密钥大小可以是128位和256位之间的32位的任何倍数。 "
":cite:`daemen:aes`当Rijndael通过FIPS标准化过程成为AES时，参数被限制在128位的组大小和128、192和256位的密钥大小。:cite:`fips:aes`"

#: ../../src/block-ciphers.rst:185
msgid ""
"There are no practical attacks known against AES. While there have been some"
" developments in the last few years, most of them involve related-key "
"attacks :cite:`cryptoeprint:2009:317`, some of them only on reduced-round "
"versions of AES :cite:`cryptoeprint:2009:374`.  [#]_"
msgstr ""
"目前还没有针对AES的实用攻击。虽然在过去的几年里有一些发展，但大多数涉及到相关密钥攻击 "
":cite:`cryptoeprint:2009:317`，其中一些只涉及到AES的简化版 :cite:`cryptoeprint:2009:374`。"
" [#]_"

#: ../../src/block-ciphers.rst:192
msgid ""
"Symmetric algorithms usually rely on a round function to be repeated a "
"number of times. Typically each invocation involves a “round key” derived "
"from the main key. A reduced-round version is intentionally easier to "
"attack. These attacks can give insight as to how resistant the full cipher "
"is."
msgstr ""
"对称算法通常依靠一个轮函数来重复多次。通常每次调用都会涉及到一个从主密钥衍生出来的 "
"\"轮密钥\"。简化版本故意更容易被攻击。这些攻击可以深入了解全加密版本的抗性。"

#: ../../src/block-ciphers.rst:198
msgid ""
"A related key attack involves making some predictions about how AES will "
"behave under several different keys with some specific mathematical "
"relation. These relations are fairly simple, such as XORing with an "
"attacker-chosen constant. If an attacker is allowed to encrypt and decrypt a"
" large number of blocks with these related keys, they can attempt to recover"
" the original key with significantly less computation than would ordinarily "
"be necessary to crack it."
msgstr ""
"相关的密钥攻击涉及到用一些特定的数学关系对AES在几种不同密钥下的表现进行一些预测。这些关系相当简单，比如用攻击者选择的常数进行XOR。如果允许攻击者用这些相关密钥加密和解密大量的区块，他们就可以尝试恢复原始密钥，其计算量比通常破解它所需的计算量要少得多。"

#: ../../src/block-ciphers.rst:206
msgid ""
"While a theoretically ideal block cipher wouldn't be vulnerable to a related"
" key attack, these attacks aren't considered practical concerns. In practice"
" cryptographic keys are generated via a cryptographically secure "
"pseudorandom number generator, or a similarly secure :term:`key agreement` "
"scheme or key derivation scheme (we'll see more about those later). "
"Therefore, the odds of selecting two such related keys by accident is "
"nonexistent. These attacks are interesting from an academic perspective: "
"they can help provide insight in the workings of the cipher, guiding "
"cryptographers in designing future ciphers and attacks against current "
"ciphers."
msgstr ""
"由于理论上理想的分组密码不会受到相关密钥攻击的影响，这些攻击并不被认为是实际问题。在实践中，密码密钥是通过一个密码学上安全的伪随机数生成器，或安全的:term:`密钥协商`方案或密钥推导方案（我们将在后面看到更多关于这些的内容）生成的。因此，偶然选择两个这样的相关密钥的几率是不存在的。从学术的角度来看，这些攻击是很有趣的：它们可以帮助提供密码工作原理的见解，指导密码学家设计未来的密码和针对当前密码的攻击。"

#: ../../src/block-ciphers.rst:218
msgid "A closer look at Rijndael"
msgstr "Rijndael的细节"

#: ../../src/block-ciphers.rst:223
msgid ""
"AES consists of several independent steps. At a high level, AES is a "
":term:`substitution-permutation network`."
msgstr "AES由几个独立的步骤组成。在高层次上，AES是一个:term: \"代换-置换网络\"。"

#: ../../src/block-ciphers.rst:227
msgid "Key schedule"
msgstr "密钥编排"

#: ../../src/block-ciphers.rst:229
msgid ""
"AES requires separate keys for each round in the next steps. The key "
"schedule is the process which AES uses to derive 128-bit keys for each round"
" from one master key."
msgstr "在接下来的步骤中，AES要求每一轮都有单独的密钥。密钥编排算法是AES用来从一个主密钥中得出每轮128位密钥的过程。"

#: ../../src/block-ciphers.rst:233
msgid ""
"First, the key is separated into 4 byte columns. The key is rotated and then"
" each byte is run through an S-box (substitution box) that maps it to "
"something else. Each column is then XORed with a round constant. The last "
"step is to XOR the result with the previous round key."
msgstr ""
"首先，密钥被分成4个字节列。键被旋转，然后每个字节通过一个S-"
"box（置换盒子）运行，将其映射到其他字节上。然后，每一列都用一个轮常数进行XOR。最后一步是将结果与前一个轮密钥进行XOR。"

#: ../../src/block-ciphers.rst:238
msgid ""
"The other columns are then XORed with the previous round key to produce the "
"remaining columns."
msgstr "然后将其他列与前一个轮密钥进行XOR，生成其余列。"

#: ../../src/block-ciphers.rst:242
msgid "SubBytes"
msgstr "SubBytes"

#: ../../src/block-ciphers.rst:244
msgid ""
"SubBytes is the step that applies the S-box (substitution box) in AES. The "
"S-box itself substitutes a byte with another byte, and this S-box is applied"
" to each byte in the AES state."
msgstr ""
"SubBytes是应用在AES中S-box（substitution box）的步骤。S-box本身就是用另一个字节来替换一个字节，这个S-"
"box被应用到AES状态下的每个字节。"

#: ../../src/block-ciphers.rst:248
msgid ""
"It works by taking the multiplicative inverse over the Galois field, and "
"then applying an affine transformation so that there are no values :math:`x`"
" so that :math:`x \\xor S(x) = 0` or :math:`x \\xor S(x)=\\texttt{0xff}`. To"
" rephrase: there are no values of :math:`x` that the substitution box maps "
"to :math:`x` itself, or :math:`x` with all bits flipped. This makes the "
"cipher resistant to linear cryptanalysis, unlike the earlier DES algorithm, "
"whose fifth S-box caused serious security problems.  [#]_"
msgstr ""
"它的工作原理是在有限域上进行乘法反演，然后应用一个仿射变换，使 :math:`x`没有值使 :math:`x/xor S(x) = 0`或 "
":math:`x/xor S(x)=\\texttt{0xff}`。换句话说： :math:`x`的值没有替换框映射到 :math:`x`本身，或者 "
"说:math:`x`所有位都被翻转了。这使得该加密可以抵抗线性密码分析，不像早期的DES算法，其第五个S-box造成了严重的安全问题。 [#]_"

#: ../../src/block-ciphers.rst:260
msgid ""
"In its defense, linear attacks were not publicly known back when DES was "
"designed."
msgstr "在 DES 被设计出来的时候，线性攻击还没有被公众所知"

#: ../../src/block-ciphers.rst:264
msgid "ShiftRows"
msgstr "ShiftRows"

#: ../../src/block-ciphers.rst:266
msgid ""
"After having applied the SubBytes step to the 16 bytes of the block, AES "
"shifts the rows in the :math:`4 \\times 4` array:"
msgstr "在将SubBytes步骤应用于该组的16个字节后，AES将 :math:`4 \\times 4`数组进行行交换。"

#: ../../src/block-ciphers.rst:273
msgid "MixColumns"
msgstr "MixColumns"

#: ../../src/block-ciphers.rst:275
msgid ""
"MixColumns multiplies each column of the state with a fixed polynomial."
msgstr "MixColumns对状态的每一列乘以一个固定的多项式。"

#: ../../src/block-ciphers.rst:277
msgid "ShiftRows and MixColumns represent the diffusion properties of AES."
msgstr "ShiftRows和MixColumns代表了AES的扩散特性。"

#: ../../src/block-ciphers.rst:283
msgid "AddRoundKey"
msgstr "AddRoundKey"

#: ../../src/block-ciphers.rst:285
msgid ""
"As the name implies, the AddRoundKey step adds the bytes from the round key "
"produced by the key schedule to the state of the cipher."
msgstr "顾名思义，AddRoundKey步骤将 key schedule产生的轮密钥的字节添加到密码的状态中。"

#: ../../src/block-ciphers.rst:292
msgid "DES and 3DES"
msgstr "DES 和 3DES"

#: ../../src/block-ciphers.rst:294
msgid ""
"The DES is one of the oldest block ciphers that saw widespread use. It was "
"published as an official FIPS standard in 1977. It is no longer considered "
"secure, mainly due to its tiny key size of 56 bits. (The DES algorithm "
"actually takes a 64 bit key input, but the remaining 8 bits are only used "
"for parity checking, and are discarded immediately.) It shouldn't be used in"
" new systems. On modern hardware, DES can be brute forced in less than a "
"day. :cite:`sciengines:breakdes`"
msgstr ""
"DES是被广泛使用的最古老的分组密码之一。它于1977年作为FIPS官方标准发布。它不再被认为是安全的，主要是因为它的密钥大小只有56位。（DES算法实际上需要一个64位的密钥输入，但剩下的8位只用于奇偶校验，并立即被丢弃）。它不应该在新系统中使用。在现代硬件上，DES可以在不到一天的时间里被暴力破解。:cite:"
" `sciengines:breakdes`。"

#: ../../src/block-ciphers.rst:302
msgid ""
"In an effort to extend the life of the DES algorithm, in a way that allowed "
"much of the spent hardware development effort to be reused, people came up "
"with 3DES: a scheme where input is first encrypted, then decrypted, then "
"encrypted again:"
msgstr "为了延长DES算法的寿命，使大部分已花费的硬件开发工作得以重用，人们想到了3DES：一种先对输入进行加密，然后解密，然后再次加密的方案："

#: ../../src/block-ciphers.rst:307
msgid "C = E_{DES}(k_1, D_{DES}(k_2, E_{DES}(k_3, p)))"
msgstr "C = E_{DES}(k_1, D_{DES}(k_2, E_{DES}(k_3, p)))"

#: ../../src/block-ciphers.rst:311
msgid "This scheme provides two improvements:"
msgstr "这个方案提供了两点改进："

#: ../../src/block-ciphers.rst:313
msgid ""
"By applying the algorithm three times, the cipher becomes harder to attack "
"directly through cryptanalysis."
msgstr "通过应用三次算法，密文就很难直接通过密码分析进行攻击"

#: ../../src/block-ciphers.rst:315
msgid ""
"By having the option of using many more total key bits, spread over the "
"three keys, the set of all possible keys becomes much larger, making brute-"
"forcing impractical."
msgstr "通过可以选择使用分布在三个密钥上的更多总密钥，所有可能的密钥集变大很多，使暴力破解变得不切实际。"

#: ../../src/block-ciphers.rst:319
msgid ""
"The three keys could all be chosen independently (yielding 168 key bits), or"
" :math:`k_3 = k_1` (yielding 112 key bits), or :math:`k_1 = k_2 = k_3`, "
"which, of course, is just plain old DES (with 56 key bits). In the last "
"keying option, the middle decryption reverses the first encryption, so you "
"really only get the effect of the last encryption. This is intended as a "
"backwards compatibility mode for existing DES systems. If 3DES had been "
"defined as :math:`E(k_1, E(k_2, E(k_3, p)))`, it would have been impossible "
"to use 3DES implementations for systems that required compatibility with "
"DES. This is particularly important for hardware implementations, where it "
"is not always possible to provide a secondary, regular “single DES” "
"interface next to the primary 3DES interface."
msgstr ""
"三个密钥都可以独立选择（产生168个密钥位），或者 :math:`k_3 = k_1`（产生112个密钥位），或者 :math:`k_1 = k_2 ="
" "
"k_3`，当然，这只是普通的DES（有56个密钥位）。在最后一个键位选项中，中间的解密会把第一次的加密反过来，所以你真正得到的只是最后一次加密的效果。这是为现有DES系统提供的一种向后兼容模式。如果3DES被定义为:math:`E(k_1,"
" E(k_2, E(k_3, "
"p)))`，那么对于需要与DES兼容的系统，就不可能使用3DES实现。这对硬件实现尤其重要，因为在硬件实现中，并不总是能够在主要的3DES接口旁边提供一个次要的、常规的"
" \"单一DES \"接口。"

#: ../../src/block-ciphers.rst:332
msgid ""
"Some attacks on 3DES are known, reducing their effective security. While "
"breaking 3DES with the first keying option is currently impractical, 3DES is"
" a poor choice for any modern cryptosystem. The security margin is already "
"small, and continues to shrink as cryptographic attacks improve and "
"processing power grows."
msgstr ""
"已知对3DES的某些攻击会降低其有效安全性。虽然用第一种密钥选项破解3DES目前还不切实际，但对于任何现代密码系统来说，3DES都是一个糟糕的选择。安全系数已经很小，而且随着密码攻击的改进和处理能力的增长，安全系数还在继续缩小。"

#: ../../src/block-ciphers.rst:338
msgid ""
"Far better alternatives, such as AES, are available. Not only are they more "
"secure than 3DES, they are also generally much, much faster. On the same "
"hardware and in the same :term:`mode of operation` (we'll explain what that "
"means in the next chapter), AES-128 only takes 12.6 cycles per byte, while "
"3DES takes up to 134.5 cycles per byte. :cite:`cryptopp:bench` Despite being"
" worse from a security point of view, it is literally an order of magnitude "
"slower."
msgstr ""
"有更好的替代品，如AES。它们不仅比3DES更安全，而且通常也快得多。在相同的硬件和相同的 "
":term:`工作模式`(我们将在下一章解释这意味着什么)，AES-128每字节只需要12.6个周期，而3DES每字节需要134.5个周期。 "
":cite:`cryptopp:bench`先不说从安全的角度来看更差，它确实慢了一个数量级。"

#: ../../src/block-ciphers.rst:346
msgid ""
"While more iterations of DES might increase the security margin, they aren't"
" used in practice. First of all, the process has never been standardized "
"beyond three iterations. Also, the performance only becomes worse as you add"
" more iterations. Finally, increasing the key bits has diminishing security "
"returns, only increasing the security level of the resulting algorithm by a "
"smaller amount as the number of key bits increases. While 3DES with keying "
"option 1 has a key length of 168 bits, the effective security level is "
"estimated at only 112 bits."
msgstr ""
"虽然DES的更多迭代可能会增加安全系数，但并没有实际使用。首先，这个过程从未被标准化超过三次迭代。另外，随着增加更多的迭代，性能只会变得更差。最后，增加密钥位的安全回报率越来越低，只是随着密钥位数的增加，所产生的算法的安全级别增加的幅度越来越小。虽然带密钥选项1的3DES的密钥长度为168位，但有效安全级别估计只有112位。"

#: ../../src/block-ciphers.rst:355
msgid ""
"Even though 3DES is significantly worse in terms of performance and slightly"
" worse in terms of security, 3DES is still the workhorse of the financial "
"industry. With a plethora of standards already in existence and new ones "
"continuing to be created, in such an extremely technologically conservative "
"industry where Fortran and Cobol still reign supreme on massive mainframes, "
"it will probably continue to be used for many years to come, unless there "
"are some large cryptanalytic breakthroughs that threaten the security of "
"3DES."
msgstr ""
"尽管3DES在性能上明显差了很多，在安全性上也略差，但3DES仍然是金融行业的主力军。由于已经有了大量的标准，而且新的标准还在不断地被创造出来，在这样一个技术极其保守的行业里，Fortran和Cobol仍然在大规模的大型机上称王称霸，它可能会在未来的很多年里继续被使用，除非有一些大的密码分析的突破，威胁到3DES的安全性。"

#: ../../src/block-ciphers.rst:367
msgid "Remaining problems"
msgstr "遗留问题"

#: ../../src/block-ciphers.rst:369
msgid "Even with block ciphers, there are still some unsolved problems."
msgstr "即有了分组密码，仍然存在一些未解决的问题。"

#: ../../src/block-ciphers.rst:371
msgid ""
"For example, we can only send messages of a very limited length: the block "
"length of the block cipher. Obviously, we'd like to be able to send much "
"larger messages, or, ideally, streams of indeterminate size. We'll address "
"this problem with a :ref:`stream cipher <stream-ciphers>`."
msgstr ""
"例如，我们只能发送长度非常有限的消息：分组加密的组长度。显然，我们希望能够发送更长的消息，或者说，理想情况下，发送大小不确定的流。我们将用一个 "
":ref:`流加密 <stream-ciphers>`来解决这个问题。"

#: ../../src/block-ciphers.rst:376
msgid ""
"Although we have reduced the key size drastically (from the total size of "
"all data ever sent under a one-time pad scheme versus a few bytes for most "
"block ciphers), we still need to address the issue of agreeing on those few "
"key bytes, potentially over an insecure channel. We'll address this problem "
"in a later chapter with a :ref:`key exchange protocol <key-exchange>`."
msgstr ""
"虽然我们已经大大减少了密钥的大小（从一次性密码本方案下发送的所有数据的总大小到大多数分组加密的几个字节），但我们仍然需要解决在不安全的信道上商定这几个密钥字节的问题。我们将在后面的一章中用一个:ref:`密钥交换协议"
" <key-exchange>`·来解决这个问题。"
